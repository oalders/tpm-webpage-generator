#!/usr/bin/env perl
#
# Program to build Toronto Perl Mongers index page.

use 5.010_001;    # for say etc.
use strict;
use warnings;

use Path::Class;
use File::Basename;
use Readonly;
use English '-no_match_vars';
use Template;
use Carp;
use File::Find::Rule;
use POSIX 'strftime';
use TPM::Meeting;

# These should be generated one day...
my $root          = q{..};
my $run_timestamp = time;    # Override for testing

my $sections = get_sections( dir( $root, 'sections' ) );
my $years_meetings
    = group_meetings_by_year( get_meetings( dir( $root, 'meetings' ) ) );
my $upcoming_or_recent
    = find_upcoming_or_recent( $years_meetings, $run_timestamp );

my $template = Template->new( { RELATIVE => 1 } );
$template->process(
    file( $root, 'templates', 'index.tt' )->stringify,
    {   sections           => $sections,
        years_meetings     => $years_meetings,
        upcoming_or_recent => $upcoming_or_recent,
        generated_at       => scalar localtime $run_timestamp,
    }
) || croak $template->error();

exit 0;

# in:
#   directory under which sections live in separate html files
# out:
#   sorted list of sections { name => ..., content => ... }
#
# File names determine the section names, the files are assumed to
# contain valid HTML.
sub get_sections {
    my ($sections_dir) = @_;
    Readonly my $SECTION_SUFFIX => '.html';

    return [
        map {
            {   name    => basename( $_, $SECTION_SUFFIX ),
                content => scalar file($_)->slurp,
            }
            }
            sort
            grep {/\Q$SECTION_SUFFIX\E\z/smox} dir($sections_dir)->children
    ];
}

# in:
#  directory for root of tree
# out:
#  ref to list of TPM::Meeting objects
sub get_meetings {
    my ($meetings_dir) = @_;
    my @meetings;

    for my $file ( find( file => name => '*.xml', in => $meetings_dir ) ) {
        my $meeting = TPM::Meeting->new;
        $meeting->load_file($file);
        push @meetings, $meeting;
    }

    return \@meetings;
}

# in:
#   ref to unordered list of meetings
# out:
#   ref to list of hashes { year => yyyy, meetings => [ ... ] }
sub group_meetings_by_year {
    my ($unordered_list) = @_;
    my @list
        = sort { $a->timestamp <=> $b->timestamp || $a->title cmp $b->title }
        @{$unordered_list};

    my @year_groups;
    for my $meeting (@list) {
        my $year = strftime( '%Y', localtime $meeting->timestamp );

        if (   @year_groups == 0
            || $year != $year_groups[-1]{year} )
        {
            push @year_groups, { year => $year, meetings => [] };
        }

        push @{ $year_groups[-1]{meetings} }, $meeting;
    }

    return \@year_groups;
}

# in:
#   return value from group_meetings_by_year
#   timestamp for "now"
# out:
#   ref to a meeting or undef
#
# Hugely expensive O(n) lookup, but in 50 years there are only going to be
# 600 meetings and I'll likely be dead.
#
# Go throuugh all the meetings in cronological order remembering the
# last one seen.  If the timestamp of the meeting is in the future then
# quit looping.  (Future relative to the timestamp passed in.)
#
# If there are no meetings undef will be returned.
# If there are no meetings in the future then the last meeting will be returned.
# If there meetings in the future then the closest meeting is returned.

sub find_upcoming_or_recent {
    my ( $years, $timestamp ) = @_;
    my $return;

YEAR_LOOP:
    for my $year ( @{$years} ) {
    MEETING_LOOP:

        for my $meeting ( @{ $year->{meetings} } ) {
            $return = $meeting;
            last YEAR_LOOP if $meeting->timestamp > $timestamp;
        }
    }

    return $return;
}

__END__

=pod

=head1 NAME

build-index - a program to build Toronto Perl Mongers' index page.

=head1 USAGE

  build-index

=head1 DESCRIPTION

This program assembles the Toronto Perl Mongers' home page out of bits and 
pieces.

=head1 REQUIRED ARGUMENTS

None

=head1 OPTIONS

=head1 DIAGNOSTICS

=head1 EXIT STATUS

0 for success, something else otherwise.

=head1 CONFIGURATION

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

=head2 Assumptions

=over 4

=item *

One event per day

=back

=head1 AUTHOR

=head1 LICENSE AND COPYRIGHT

=cut
